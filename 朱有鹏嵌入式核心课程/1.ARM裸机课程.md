##    1.2.8 CPU和外部存储器的接口

Soc常用外存：

NorFlash ：  总线式访问，可以连接到SROM接口，价格比较贵，一般用来做启动

NandFlash  ：分为SLC（价格高，容量小，稳定性好、不容易出现坏块 ）和MLC（价格低，容量高，容易出现坏块）

eMMC/iNand/moviNand:

eMMC（嵌入的MMC卡）、iNand是SanDisk公司出的，moviNand是三星公司出的

oneNand：三星公司自己出的

SD卡/TF卡/MMC卡

eSSD（嵌入的固态硬盘）



SATA硬盘（机械式访问、磁存储原理、SATA是接口）

![image-20240311214231008](C:\Users\Windows11\AppData\Roaming\Typora\typora-user-images\image-20240311214231008.png)

SD的通道有四个，通道0接了内部的iNand，通道2接了外部的SD2

总结：外部存储设备和CPU连接一般不是通过地址&数据总线直接连接，因为地址空间不够用，一般都是通过总线连接



## 1.2.9 S5PV210的启动过程详解

内存：

SRAM：静态内存，特点：容量小，价格高，优点：上电后，可以直接使用

DRAM：动态内存，特点：容量大，价格低，缺点上电后需要代码来初始化



外存：

NorFlash：容量小，价格高，优点可以总线式连接

NandFlash：（和硬盘一样）特点是容量大，价格低，缺点是不能总线式访问，也需要初始化代码，通过一定的时序来读写

所以

一般PC机：小容量 Bios（NorFlash）+大容量硬盘（NandFlash）+ 大容量DRAM

一般的单片机: NorFlash + SRAM

嵌入式系统：（大容量）NandFlash + SOC内置的SRAM+（大容量）DRAM

因为嵌入式系统

S5PV210的启动方式：嵌入式系统这种方式

210内置了一个96KB的SRAM（叫iRAM）同时还内置了64KB的NorFlash（叫iROM）





#### 210的启动过程大致是：

**第一步**：CPU上电后先从内部IROM中读取预先设置好的代码（BL0） ，执行，这一段IROM代码首先做了一些基本的初始化（CPU时钟，关看门狗...）(这一段IROM代码是三星出厂前设置的，三星也不知道我们板子将来接的是什么DRAM因此这一段不能负责初始化外接的DRAM的，因此这一段代码只能用来初始化SOC内部的东西)，然后代码会判定我们选择的启动模式，（我们通过硬件跳线可更改板子的启动模式），然后从响应的外部存储器去读取第一部分启动代码（BL1，大小为16kB）到内部SRAM

**第二步**：从SRAM去运行刚上一步读取的启动代码（BL1 16KB），然后执行，BL1启动代码就负责初始化NandFlash，然后将BL2读取到IRAM（剩余的80KB），

**第三步**：

从IRAM运行BL2，BL2初始化DRAM，然后将OS读取到DRAM中，然后运行

<img src="D:\笔记\my_note\pic\1.ARM裸机课程\image-20240312085839711.png" style="zoom:50%;" />



整体流程：先从BL0读取代码，找到启动介质的启动方式，然后把BL1读取到内部的SRAM，BL1运行之后读取BL2到内部SRAM中（初始化NandFlash），BL2再初始化外部是DRAM的代码，然后将OS读取到外部的DRAM中执行

#### 210的启动

210的启动有二次启动的功能，当第一次启动失败后，会进行2次启动的尝试，将尝试SD卡通道2启动

当把SD作为启动项时，SD通道0作为第一次启动项，SD通道2作为第二次启动



#### BL0都做了什么？

关看门狗

初始化指令cache

初始化栈（C语言的环境只有初始化好了堆栈之后才能使用，需要一定的运行环境）

初始化堆

初始化块设备复制函数（CPU内部已经烧录好了，在一定的地址上放着一些预定义的函数，我们直接在这个地址处运行就行了）

初始化PLL和SOC时钟

复制BL1到内部的SRAM（16KB）

检查BL1的校验和

跳转到BL1执行

###  启动过程流程图：

![image-20240316070103938](E:\课程笔记\pic\image-20240316070103938.png)

wakeup 指的是休眠状态，当芯片处于低功耗的时候，NandFlash和DRAM都已经初始化过了，所以直接跳转执行就行

OM Pin：根据板子的硬件管脚来选择读取的BL1代码的方式

### S5PV210的所有启动

![image-20240316074011730](E:\课程笔记\pic\image-20240316074011730.png)

先1st启动，通过OMpin选择启动

再2nd启动，从SD2

再UART启动，

再USB启动

![image-20240316074958440](E:\课程笔记\pic\image-20240316074958440.png)



## 1.2.11 如何再开发板上选择启动方式

从SD0的eMMC启动

开发板默认是从eMMC启动

### SD卡启动 一般用于产品烧录代码

### USB调试模式：一般用于Debug代码阶段



## 1.2.12 ARM的编程模式和7种模式

### ARM处理器工作模式

![image-20240316083806982](E:\课程笔记\pic\image-20240316083806982.png)

说明：

除User模式之外，另外6个都是特权模式

特权模式：Sys模式 + 异常模式

各种模式的切换可以主动切换（写CPSR寄存器），另外一种是CPU在某些情况下自动切换

各种模式下的权限和可以访问的寄存器不同，

### 为什么要设计这么多的模式？

操作系统有安全级别的要求，因此要兼容操作系统的特性，所以硬件设计上会考虑到软件的特性来设计，

## 1.2.13 ARM的37个寄存器

![image-20240316090018235](E:\课程笔记\pic\image-20240316090018235.png)



1、ARM总共有37个寄存器，但是每种模式下最多只能看到18个寄存器，其他寄存器名字虽然相同，但是在当前模式下不可见，

2、对R13来说，在ARM中有6个名叫R13的（也叫SP）寄存器，但是在每种特定处理器模式下，只有一个R13是当前可见的，其他的R13必须切换到它的对应模式下才能看到，这种设计叫做影子寄存器（banked register）

![image-20240316095644749](E:\课程笔记\pic\image-20240316095644749.png)

SP是堆栈指针，

LR 用作返回控制，在每种状态下的返回地址

![image-20240316103846560](E:\课程笔记\pic\image-20240316103846560.png)

N表示运算结果是个负结果

Z表示表示运算结果是零

C表示进位标志位

V表示溢出



## 1.2.14 ARM的异常处理方式简单介绍

























# TODO：

1.2.10 
